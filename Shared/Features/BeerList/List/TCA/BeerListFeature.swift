//
//  BeerListFeature.swift
//  Beers
//
//  Created Christian Elies on 23.04.21.
//  Copyright Â© 2021 Christian Elies. All rights reserved.
//
//  Template generated by Christian Elies @crelies
//  https://www.christianelies.de
//

import ComposableArchitecture
import Foundation
import IdentifiedCollections

struct BeersResult: Equatable {
    let beers: [Beer]
    let page: Int
}

struct BeerListFeature: ReducerProtocol {
    struct State: Equatable {
        var page: Int = 0
        var viewState: ViewState<IdentifiedArrayOf<BeerListRowFeature.State>, BeerListError>
        var selection: BeerDetailFeature.State?
        var isLoading: Bool
    }

    enum Action: Equatable {
        case onAppear
        case row(index: BeerListRowFeature.State.ID, action: BeerListRowFeature.Action)
        case fetchBeers
        case fetchBeersResponse(Result<BeersResult, BeerListError>)
        case selectBeer(beer: Beer?)
        case setBeerPresented(isPresented: Bool)
        case beerDetail(BeerDetailFeature.Action)
        case move(indexSet: IndexSet, toOffset: Int)
        case delete(indexSet: IndexSet)
        case refresh
    }

    @Dependency(\.mainQueue) var mainQueue
    @Dependency(\.beerClient) var beerClient

    var body: some ReducerProtocol<State, Action> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                guard state.page == 0 else {
                    return .none
                }
                return .init(value: .fetchBeers)

            case let .fetchBeersResponse(.success(result)):
                state.isLoading = false
                state.page = result.page

                let rowStates = result.beers.map(BeerListRowFeature.State.init)
                state.viewState = .loaded(.init(uniqueElements: rowStates))

            case let .fetchBeersResponse(.failure(error)):
                state.isLoading = false
                state.viewState = .failed(error)

            case let .row(id, rowAction):
                switch rowAction {
                case .onAppear:
                    guard state.viewState != .loading else {
                        return .none
                    }

                    guard let beerIndex = state.viewState.value?.firstIndex(where: { $0.id == id }) else {
                        return .none
                    }

                    let lastIndex = (state.viewState.value ?? []).endIndex - 1
                    guard beerIndex == lastIndex - 5 else {
                        return .none
                    }

                    state.isLoading = true

                    return beerClient.nextBeers()
                        .receive(on: mainQueue)
                        .catchToEffect(Action.fetchBeersResponse)
                        .cancellable(id: BeerListCancelID(), cancelInFlight: true)

                case .delete:
                    state.viewState.value?.remove(id: id)
                    return beerClient.deleteBeerWithID(id)
                        .fireAndForget()
                }

            case .setBeerPresented(false):
                state.selection = nil

            case let .selectBeer(beer):
                if let beer {
                    state.selection = .init(beer: beer)
                } else {
                    state.selection = nil
                }

            case let .move(indexSet, toOffset):
                state.viewState.value?.move(fromOffsets: indexSet, toOffset: toOffset)
                return beerClient.moveBeer(indexSet, toOffset)
                    .fireAndForget()

            case let .delete(indexSet):
                indexSet.forEach { state.viewState.value?.remove(at: $0) }
                return beerClient.deleteBeer(indexSet)
                    .fireAndForget()

            case .fetchBeers:
                state.isLoading = true
                return beerClient.fetchBeers()
                    .receive(on: mainQueue)
                    .map { BeersResult(beers: $0, page: 1) }
                    .catchToEffect(Action.fetchBeersResponse)
                    .cancellable(id: BeerListCancelID(), cancelInFlight: true)

            case .refresh:
                return .init(value: .fetchBeers)

            default: ()
            }

            return .none
        }
        // TODO:
//        .forEach(\.viewState.value!, action: /Action.row) {
//            BeerListRowFeature()
//        }
        .ifLet(\.selection, action: /Action.beerDetail) {
            BeerDetailFeature(fetchBeer: beerClient.fetchBeer)
        }
    }
}
